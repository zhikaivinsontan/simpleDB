package jsonDB.relops;

import jsonDB.data.Row;
import jsonDB.validation.Query;
import jsonDB.validation.Schema;
import jsonDB.data.Predicate;
import jsonDB.data.Predicate.*;

import java.util.List;

import jsonDB.validation.Table;

import jsonDB.db.*;

import jsonDB.relops.Projection;

public abstract class Iterator {
	
	//The Schema that all tuples that are output from this Iterator will be defined under
	protected Schema schema;
	
	/*
	 * Returns true if the Iterator is Open, false otherwise.
	 */
	public abstract boolean isOpen();
	
	/*
	 * Closes the Iterator and releases the relation and any other resources. Closes any child Iterators.
	 */
	public abstract void close();
	
	/*
	 * Reset the Iterator to the beginning state, as if it was just opened.
	 * This has undefined behavior on a closed Iterator. It is the caller's responsibility to ensure
	 * that the Iterator is not closed.
	 */
	public abstract void reset();
	
	/*
	 * Computes the next value that will be returned by the Iterator. If a next value is successfully 
	 * computed, return true. Else return false.
	 * 
	 * If hasNext() is called multiple times in a row without a call to getNext(), do not advance
	 * the Iterator to the next value, simply return whatever the previous result was.
	 * 
	 * This has undefined behavior on a closed Iterator. It is the caller's responsibility to ensure
	 * that the Iterator is not closed.
	 */
	public abstract boolean hasNext();
	
	
	/*
	 * Returns the value last computed by hasNext(). Throw an illegal state exception if there are no
	 * more rows to return or if getNext() has been called multiple times in a row without a hasNext()
	 * call. It is the caller's responsibility to ensure that every call to getNext() is immediately
	 * preceeded by a call to hasNext().
	 * 
	 * This has undefined behavior on a closed Iterator. It is the caller's responsibility to ensure
	 * that the Iterator is not closed.
	 */
	public abstract Row getNext();
	
	/*
	 * Execute the Iterator - report as many results as are generated by the Iterator
	 * pipeline.
	 */
	public void execute()
	{
		System.out.println(schema.toString());
		while(hasNext())
		{
			System.out.println(getNext().toString());
		}
		close();
	}
	
	/*
	 * For a given Query, create a pipeline of Iterators that can be used to execute that Query.
	 * 
	 * The fromTable field in the Query specifies the name of the base file to read from.
	 * 
	 * The selectFields field in the Query specifies the fields that should be included in the output.
	 * 
	 * The wherePredicates field in the Query specifies the Predicates that rows must satisfy. These
	 * Predicates are in Conjunctive Normal Form (CNF), represented as a 2-dimensional array. The
	 * first dimension represents the clauses in the CNF representation, and the second dimension
	 * represents the conjunctive predicates within each clause.
	 * 
	 * For example, for the set of predicates (P1 && P2) || (Q1 && Q2):
	 * CNF representation:
	 * 	(P1 || Q1) && (P2 || Q1) && (P1 || Q2) && (P2 || Q2)
	 * Array representation:
	 * { {P1, Q1},
	 *   {P2, Q1},
	 *   {P1, Q2},
	 *   {P2, Q2} }
	 *   
	 *  OR operations are evaluated within one Select operator. AND operations are evaluated by
	 *  pipelining multiple Select operators.
	 */
	public static Iterator createPlan(Query q)
	{
		//TODO
		Table table = SimpleDB.db.getTable(q.getFromTable());
		Iterator fs = new FileScan(table);
		//fs.setSchema(table.getSchema());
		
				
		List<List<Predicate>> preddies = q.getWherePredicates();

		if(preddies.size() == 0) {
		
			Iterator proj = new Projection(fs,q.getSelectFields());		
			proj.setSchema(Projection.project(table.getSchema(),q.getSelectFields()));
		
			return proj;

		} else {
			Iterator sel = null;
			for(int i = 0; i < preddies.size(); i++){

				if(i == 0) {
					sel = new Selection(fs,preddies.get(i));
					//sel.setSchema(table.getSchema());
				} else {
					sel = new Selection(sel,preddies.get(i));
					//sel.setSchema(table.getSchema());
				}
			}
		
			Iterator proj = new Projection(sel,q.getSelectFields());
			proj.setSchema(Projection.project(table.getSchema(),q.getSelectFields()));
		
			return proj;
		}
	}
	
	/* Getters and setters */
	
	public Schema getSchema()
	{
		return schema;
	}
	
	public void setSchema(Schema s)
	{
		schema = s;
	}

}
